"""
Написать два алгоритма нахождения i-го по счёту простого числа.
- Без использования «Решета Эратосфена»
- Используя алгоритм «Решето Эратосфена»
"""
from timeit import timeit
import cProfile


def prime(x):
    i = 1
    item = 1
    array = [2]
    while i < x:
        item += 2  # рассматриваем только нечётные числа
        composite = False
        for r in array:
            if item % r == 0:
                composite = True
                break
        if not composite:
            array.append(item)
            i += 1
    return item


def sieve(x):
    m = 5000
    array2 = list(range(m + 1))
    array2[1] = 0  # без этой строки итоговый список будет содержать единицу
    for i in array2:
        if i > 1:
            for j in range(i + i, len(array2), i):
                array2[j] = 0
    prime_array = [i for i in array2 if i > 0]
    return prime_array[x-1]


def main():
    n = 50

    print(f'\nОбычный алгоритм: {n}-ое простое число = {prime(n)}')
    print(f'\nРешето Эратосфена: {n}-ое простое число = {sieve(n)}')

    print('')
    for r in range(n):
        res = timeit(f'r = prime({r * 10})', number=100, globals=globals())
        print(f'{res:5.7f}')

    print('')
    for r in range(n):
        res = timeit(f'r = sieve({r * 10})', number=100, globals=globals())
        print(f'{res:5.7f}')


cProfile.run('main()')

"""
При небольших значениях N простой алгоритм быстрее "решета Эратосфена", однако время выполнения растет с увеличением N
У алгоритма "Решето Эратосфена" при любом значении N время выполнения примерно одинаково. При больших значениях N этот
алгоритм намного быстрее простого алгоритма. И это еще без учета избыточного множества чисел (избыточность влияет 
на время выполнения задачи) - чтобы N-е число гарантированно было в пределах множества.


Обычный алгоритм:           Решето Эратосфена:
0.0000227                   0.0725219
0.0004468                   0.0735844
0.0011311                   0.0715104
0.0021234                   0.0712047
0.0038436                   0.0729899
0.0052172                   0.0700081
0.0068688                   0.0713599
0.0093595                   0.0713133
0.0121253                   0.0722141
0.0149007                   0.0708788
0.0181658                   0.0722882
0.0217403                   0.0728037
0.0255531                   0.0706398
0.0294590                   0.0700779
0.0336622                   0.0693322
0.0402017                   0.0723733
0.0432903                   0.0711840
0.0494992                   0.0695165
0.0540625                   0.0690911
0.0598780                   0.0713990
0.0663811                   0.0733840
0.0735638                   0.0726774
0.0784849                   0.0723015
0.0860328                   0.0709326
0.0912479                   0.0704622
0.1010934                   0.0715885
0.1060454                   0.0728327
0.1131550                   0.0712482
0.1240063                   0.0701540
0.1349030                   0.0736622
0.1464805                   0.0710964
0.1546784                   0.0703862
0.1622319                   0.0710914
0.1683879                   0.0723520
0.1829670                   0.0700203
0.1933245                   0.0695336
0.2013761                   0.0724852
0.2148288                   0.0706440
0.2246725                   0.0693301
0.2404151                   0.0726420
0.2461807                   0.0722664
0.2600820                   0.0729220
0.2765509                   0.0719996
0.2847099                   0.0710824
0.3020446                   0.0734829
0.3098980                   0.0710932
0.3255511                   0.0712437
0.3378038                   0.0727646
0.3529376                   0.0711001
0.3661443                   0.0724025

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     5001    6.266    0.001    6.353    0.001 Task4-2.py:10(prime)
     5001    2.885    0.001    3.536    0.001 Task4-2.py:27(sieve)
"""
